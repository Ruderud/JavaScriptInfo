<!DOCTYPE html>
<html>
    <body>
        <script>
            "use strict";
            //비교연산자 >,<,==,!= 모두 파이썬과 동일. 결과를 boolean형으로 반환하는것도 같다.

            //문자열비교;사전편집(lexicographical)방법에 따라, 사전뒤쪽의 문자열(엄밀히는 유니코드 순)일수록 커지는것으로 한다.
            alert( "Z" > "A" ); //True
            alert( 'glow' > 'glee' ); //True
            alert( 'bee' > 'be'); //True
            alert( 'a' > 'A'); //True -> 유니코드에서 소문자가 대문자 뒤에있음 = 소문자가 대문자보다 큼

            alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행       중요!! 서로 문자열이 "다를때"만 자동변환!
            alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행

            let a = 0;
            alert( Boolean(a) ); // false
            let b = "0";
            alert( Boolean(b) ); // true
            alert(a == b); // true! -> b에 할당된 문자열 "0"이 숫자와 비교시에는 숫자열 0으로 변환되기때문에 이런일이 일어남
        
            alert( 0 == false /* == '' (공란)도 true반환*/ ); // true -> 불린 문자 숫자의 부정형만 판단
            alert( 0 === false); //False -> 엄격한 판단기준이므로 문자열형태가 달라 false가 반환된다. 엄격 부등호일때는 !==를 사용

            alert( null === undefined ); // false -> 엄밀히 둘은 다르므로 엄격판단기준에서는 거짓이 반환
            alert( null == undefined ); // true -> 동등연산만 한다면 특별 규칙에 의해 참이 반환.
            //null은 숫자형 0, undefined는 숫자형 NaN으로 변할수 있음. (둘다 숫자형으로 바뀜!)

            alert( null > 0 );  // (1) false  -> null -> 0으로 변환 -> 거짓!
            alert( null == 0 ); // (2) false  -> null은 동등연산자(==)일때는 형변환이 일어나지않기에 거짓이 반환
            alert( null >= 0 ); // (3) true   -> null -> 0으로 변환 -> 참!

            alert( undefined > 0 ); // false (1)
            alert( undefined < 0 ); // false (2)    -> 1,2에서는 undefined->NaN(숫자형)으로 변환이 일어남. 그러나 비교연산자에 대해 
                                                     //undefined가 피연산자일 경우 "항상 False를 반환"한다.
            alert( undefined == 0 ); // false (3)   -> null과 같을수는 있어도 0은 아니기때문에 false반환.


            /*
            Q. T/F->T/F/T/F/F/F
            "2">"12" -> 참인 이유는 둘다 문자열로 같기때문에 문자열로써 비교하면 뒤에 있는 유니코드인 2가 1보다 크기때문에 "2"가 "12"보다 큼
            */
        </script>
    </body>
</html>
